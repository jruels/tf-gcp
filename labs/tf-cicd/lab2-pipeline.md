# Terraform CI/CD Lab 2: Pipeline and State Management

## Overview
In this lab, you will:
1. Set up a GitLab CI/CD pipeline
2. Configure remote state management in GCS
3. Generate dynamic backend configurations

## Steps

### 1. Create a GCS Bucket for State Management

1. Create a bucket for Terraform state:
```bash
gsutil mb -l us-central1 gs://iis-tf-dev-state-$(date +%Y%m%d)
```

2. Enable versioning:
```bash
gsutil versioning set on gs://iis-tf-dev-state-$(date +%Y%m%d)
```

### 2. Create GitLab CI/CD Pipeline

Create `.gitlab-ci.yml` in your repository:

```yaml
image: hashicorp/terraform:1.5

variables:
  TF_VAR_project_id: $PROJECT_ID
  GOOGLE_APPLICATION_CREDENTIALS: ${CI_PROJECT_DIR}/credentials.json
  STATE_BUCKET: "iis-tf-dev-state-20240319"  # Replace with your bucket name

.generate_backend_config: &generate_backend_config |
  # Generate backend config based on environment
  cat > backend.tf << EOF
  terraform {
    backend "gcs" {
      bucket = "${STATE_BUCKET}"
      prefix = "tf-lab3/${ENV}"
    }
  }
  EOF

stages:
  - validate
  - plan
  - apply

before_script:
  - echo $GCP_SA_KEY > ${CI_PROJECT_DIR}/credentials.json
  - cd tf-lab3
  - *generate_backend_config  # Generate backend config for this job

validate:
  stage: validate
  variables:
    ENV: dev  # Default to dev for validation
  script:
    - terraform init
    - terraform fmt -check
    - terraform validate
  rules:
    - if: $CI_MERGE_REQUEST_ID
    - if: $CI_COMMIT_BRANCH == "main"

.plan_template: &plan_definition
  script:
    - terraform init
    - terraform plan -var-file=${ENV}.tfvars -out=plan.tfplan
  artifacts:
    paths:
      - plan.tfplan
    expire_in: 1 week

plan_dev:
  <<: *plan_definition
  stage: plan
  variables:
    ENV: dev
  rules:
    - if: $CI_MERGE_REQUEST_ID
    - if: $CI_COMMIT_BRANCH == "main"

plan_prod:
  <<: *plan_definition
  stage: plan
  variables:
    ENV: prod
  rules:
    - if: $CI_COMMIT_BRANCH == "main"

.apply_template: &apply_definition
  script:
    - terraform init
    - terraform apply plan.tfplan
  dependencies:
    - plan_${ENV}
  when: manual

apply_dev:
  <<: *apply_definition
  stage: apply
  variables:
    ENV: dev
  rules:
    - if: $CI_MERGE_REQUEST_ID
    - if: $CI_COMMIT_BRANCH == "main"

apply_prod:
  <<: *apply_definition
  stage: apply
  variables:
    ENV: prod
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
```

### 3. Configure GitLab Variables

In GitLab, go to Settings > CI/CD > Variables and add:
1. `PROJECT_ID`: Your GCP project ID
2. `GCP_SA_KEY`: Your service account key JSON (masked)
3. `STATE_BUCKET`: Your GCS bucket name for state storage

### 4. Update main.tf

Update `main.tf` to remove any existing backend configuration (it will be generated by the pipeline):

```hcl
terraform {
  required_providers {
    google = {
      source  = "hashicorp/google"
      version = "~> 4.0"
    }
    random = {
      source  = "hashicorp/random"
      version = ">= 3.1.0"
    }
  }
}
```

### 5. Test the Pipeline

1. Commit and push your changes:
```bash
git add .
git commit -m "Add CI/CD pipeline with dynamic backend configuration"
git push origin main
```

2. Go to GitLab > CI/CD > Pipelines to see your pipeline running

3. The pipeline will:
   - Generate appropriate backend configuration for each job
   - Validate the Terraform configuration
   - Create plans for both environments
   - Wait for manual approval before applying

## Important Notes

1. State Management:
   - Each environment's state is stored in a different path in the GCS bucket
   - Dev state: `tf-lab3/dev/terraform.tfstate`
   - Prod state: `tf-lab3/prod/terraform.tfstate`
   - Backend configuration is generated dynamically by the pipeline

2. Pipeline Security:
   - Production deployments only run on main branch
   - All applies require manual approval
   - Service account has limited permissions

3. Best Practices:
   - Always review the plan before approving apply
   - Use merge requests for changes
   - Keep sensitive variables secure in GitLab

## Next Steps
In the next labs, you will:
1. Add automated testing
2. Implement drift detection
3. Add cleanup jobs 